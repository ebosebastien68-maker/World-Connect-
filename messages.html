<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Connect - Messages</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="messages.css">
</head>
<body>
    <canvas id="three-canvas"></canvas>
    
    <div class="messages-wrapper">
        <div class="messages-header">
            <h1><i class="fas fa-globe"></i> <span id="header-title">World Connect</span></h1>
            <div class="header-actions">
                <button class="action-btn secondary" onclick="openConversationsModal()">
                    <i class="fas fa-list"></i>
                    <span>Conversations</span>
                </button>
                <button class="action-btn" onclick="openContactsModal()">
                    <i class="fas fa-user-plus"></i>
                    <span id="contacts-btn-text">Contacts</span>
                </button>
            </div>
        </div>

        <div class="messages-container">
            <div class="chat-area" id="chat-area">
                <div class="empty-state">
                    <i class="fas fa-spinner fa-spin"></i>
                    <h3>Chargement...</h3>
                </div>
            </div>
        </div>
    </div>

    <!-- Voice recording indicator -->
    <div class="recording-indicator" id="recording-indicator">
        <div class="recording-wave">
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
        </div>
        <div class="recording-time" id="recording-time">00:00</div>
        <div class="recording-text">üé§ Enregistrement vocal en cours...<br>Cliquez √† nouveau pour arr√™ter</div>
    </div>

    <!-- Modal Conversations -->
    <div class="modal" id="conversations-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-comments"></i> Conversations r√©centes</h3>
                <button class="close-modal" onclick="closeConversationsModal()">√ó</button>
            </div>
            <div class="modal-search">
                <input type="text" placeholder="Rechercher une conversation..." id="search-conversations">
            </div>
            <div class="list-container" id="conversations-list"></div>
        </div>
    </div>

    <!-- Modal Contacts -->
    <div class="modal" id="contacts-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-address-book"></i> <span id="contacts-modal-title">Contacts</span></h3>
                <button class="close-modal" onclick="closeContactsModal()">√ó</button>
            </div>
            <div class="modal-search">
                <input type="text" placeholder="Rechercher un contact..." id="search-contacts">
            </div>
            <div class="list-container" id="contacts-list"></div>
        </div>
    </div>

    <script src="supabaseClient.js"></script>
    <script>
        // ==================== THREE.JS ANIMATION ====================
        const canvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        camera.position.z = 50;

        // Particules
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 3000;
        const posArray = new Float32Array(particlesCount * 3);
        
        for(let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 150;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.3,
            color: 0x4a90e2,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // Lignes de connexion
        const linesGroup = new THREE.Group();
        scene.add(linesGroup);
        
        function createConnectionLines() {
            for(let i = 0; i < 80; i++) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                
                positions[0] = (Math.random() - 0.5) * 100;
                positions[1] = (Math.random() - 0.5) * 100;
                positions[2] = (Math.random() - 0.5) * 100;
                positions[3] = (Math.random() - 0.5) * 100;
                positions[4] = (Math.random() - 0.5) * 100;
                positions[5] = (Math.random() - 0.5) * 100;
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: 0x3a7bc8,
                    transparent: true,
                    opacity: 0.2
                });
                
                const line = new THREE.Line(geometry, material);
                linesGroup.add(line);
            }
        }
        
        createConnectionLines();

        // Sph√®re centrale
        const sphereGeometry = new THREE.SphereGeometry(8, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0x2e5c8a,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.001;
            
            particlesMesh.rotation.y = time * 0.3;
            particlesMesh.rotation.x = time * 0.2;
            sphere.rotation.y = time * 0.5;
            sphere.rotation.x = time * 0.3;
            linesGroup.rotation.y = time * 0.2;
            linesGroup.rotation.z = time * 0.1;
            particlesMaterial.opacity = 0.5 + Math.sin(time * 2) * 0.3;
            
            renderer.render(scene, camera);
        }
        
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== VARIABLES GLOBALES ====================
        let supabaseInstance, getCurrentUser, getUserProfile, redirectByRole;
        let currentUser = null;
        let userProfile = null;
        let currentChatUser = null;
        let messageSubscription = null;
        let typingSubscription = null;
        let deliverySubscription = null;
        let conversationsCache = [];
        let contactsCache = [];
        let typingTimeout = null;
        let isTyping = false;
        let selectedImage = null;
        let selectedFile = null;
        let messagesCache = [];
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimer = null;

        // ==================== INITIALISATION ====================
        function initializeApp() {
            if (window.supabaseClient) {
                supabaseInstance = window.supabaseClient.supabase;
                getCurrentUser = window.supabaseClient.getCurrentUser;
                getUserProfile = window.supabaseClient.getUserProfile;
                redirectByRole = window.supabaseClient.redirectByRole;
                
                initApp();
            } else {
                setTimeout(initializeApp, 100);
            }
        }

        async function initApp() {
            currentUser = await getCurrentUser();
            if (!currentUser) {
                window.location.href = 'connexion.html';
                return;
            }

            userProfile = await getUserProfile(currentUser.id);
            await initInterface();

            document.getElementById('search-conversations').addEventListener('input', (e) => filterList('conversations', e.target.value));
            document.getElementById('search-contacts').addEventListener('input', (e) => filterList('contacts', e.target.value));
            
            document.addEventListener('click', (e) => {
                const menu = document.getElementById('attach-menu');
                const btn = document.getElementById('attach-btn');
                if (menu && !menu.contains(e.target) && !btn.contains(e.target)) {
                    menu.classList.remove('show');
                }
            });
        }

        window.addEventListener('DOMContentLoaded', initializeApp);

        async function initInterface() {
            if (userProfile.role === 'user') {
                document.getElementById('contacts-btn-text').textContent = 'Admins';
                document.getElementById('contacts-modal-title').textContent = 'Administrateurs';
                await initUserChat();
            } else {
                document.getElementById('contacts-btn-text').textContent = 'Contacts';
                document.getElementById('contacts-modal-title').textContent = 'Tous les contacts';
                await initAdminChat();
            }
        }

        async function initUserChat() {
            const storedAdminId = localStorage.getItem(`default_admin_${currentUser.id}`);
            let defaultAdmin = null;

            if (storedAdminId) {
                const { data } = await supabaseInstance
                    .from('users_profile')
                    .select('*')
                    .eq('user_id', storedAdminId)
                    .eq('role', 'admin')
                    .single();
                defaultAdmin = data;
            }

            if (!defaultAdmin) {
                const { data: admins } = await supabaseInstance
                    .from('users_profile')
                    .select('user_id, prenom, nom, role')
                    .eq('role', 'admin')
                    .limit(10);

                if (admins && admins.length > 0) {
                    defaultAdmin = admins[Math.floor(Math.random() * admins.length)];
                    localStorage.setItem(`default_admin_${currentUser.id}`, defaultAdmin.user_id);
                }
            }

            if (defaultAdmin) {
                openChat(defaultAdmin);
            } else {
                showEmptyState('Aucun administrateur disponible', 'Veuillez r√©essayer plus tard');
            }

            await loadConversations();
        }

        async function initAdminChat() {
            await loadConversations();
            
            if (conversationsCache.length > 0) {
                openChat(conversationsCache[0].user);
            } else {
                showEmptyState('Aucune conversation', 'Attendez qu\'un utilisateur vous contacte');
            }
        }

        // ==================== CHARGEMENT DONN√âES (VERSION ORIGINALE CORRIG√âE) ====================
        async function loadConversations() {
            try {
                // ‚úÖ M√âTHODE ORIGINALE : Une seule requ√™te avec .or()
                const { data: messages, error } = await supabaseInstance
                    .from('messages')
                    .select('message_id, sender_id, receiver_id, texte, image_url, audio_url, date_created, read_status, delivery_status')
                    .or(`sender_id.eq.${currentUser.id},receiver_id.eq.${currentUser.id}`)
                    .order('date_created', { ascending: false })
                    .limit(200);

                if (error) throw error;

                const userIds = new Set();
                messages.forEach(msg => {
                    const otherId = msg.sender_id === currentUser.id ? msg.receiver_id : msg.sender_id;
                    userIds.add(otherId);
                });

                if (userIds.size === 0) {
                    conversationsCache = [];
                    return;
                }

                const { data: users, error: usersError } = await supabaseInstance
                    .from('users_profile')
                    .select('user_id, prenom, nom, role')
                    .in('user_id', Array.from(userIds));

                if (usersError) throw usersError;

                const usersMap = {};
                users.forEach(u => { usersMap[u.user_id] = u; });

                const conversations = {};
                messages.forEach(msg => {
                    const otherId = msg.sender_id === currentUser.id ? msg.receiver_id : msg.sender_id;
                    const otherUser = usersMap[otherId];

                    if (!otherUser) return;
                    if (userProfile.role === 'user' && otherUser.role !== 'admin') return;

                    if (!conversations[otherId]) {
                        conversations[otherId] = {
                            user: otherUser,
                            lastMessage: msg,
                            unread: 0
                        };
                    }
                    if (msg.receiver_id === currentUser.id && !msg.read_status) {
                        conversations[otherId].unread++;
                    }
                });

                conversationsCache = Object.values(conversations).sort((a, b) =>
                    new Date(b.lastMessage.date_created) - new Date(a.lastMessage.date_created)
                );

            } catch (error) {
                console.error('Erreur chargement conversations:', error);
                conversationsCache = [];
            }
        }

        async function loadMessages(otherUserId) {
            try {
                // ‚úÖ M√âTHODE ORIGINALE : Une seule requ√™te avec .or()
                const { data, error } = await supabaseInstance
                    .from('messages')
                    .select('message_id, sender_id, texte, image_url, audio_url, date_created, delivery_status, read_status')
                    .or(`and(sender_id.eq.${currentUser.id},receiver_id.eq.${otherUserId}),and(sender_id.eq.${otherUserId},receiver_id.eq.${currentUser.id})`)
                    .order('date_created', { ascending: true })
                    .limit(200);

                if (error) throw error;
                messagesCache = data || [];
                
                if (messagesCache.length > 0) {
                    const messageIds = messagesCache.map(m => m.message_id);
                    const { data: files } = await supabaseInstance
                        .from('message_files')
                        .select('*')
                        .in('message_id', messageIds);
                    
                    if (files) {
                        messagesCache.forEach(msg => {
                            msg.files = files.filter(f => f.message_id === msg.message_id);
                        });
                    }
                }
                
                displayMessages(messagesCache);
            } catch (error) {
                console.error('Erreur chargement messages:', error);
                messagesCache = [];
                showEmptyState('Erreur de chargement', 'Impossible de charger les messages');
            }
        }

        async function loadContacts() {
            try {
                const role = userProfile.role === 'user' ? 'admin' : null;
                let query = supabaseInstance
                    .from('users_profile')
                    .select('user_id, prenom, nom, role')
                    .neq('user_id', currentUser.id)
                    .order('prenom')
                    .limit(100);

                if (role) {
                    query = query.eq('role', role);
                }

                const { data, error } = await query;
                if (error) throw error;
                contactsCache = data || [];
            } catch (error) {
                console.error('Erreur chargement contacts:', error);
                contactsCache = [];
            }
        }

        // ==================== AFFICHAGE ====================
        function displayConversations(conversations) {
            const container = document.getElementById('conversations-list');

            if (conversations.length === 0) {
                container.innerHTML = '<div class="loading"><i class="fas fa-inbox"></i><p>Aucune conversation</p></div>';
                return;
            }

            container.innerHTML = '';
            conversations.forEach(conv => {
                const initials = `${conv.user.prenom[0]}${conv.user.nom[0]}`.toUpperCase();
                let lastMsg;
                if (conv.lastMessage.audio_url) {
                    lastMsg = 'üéµ Message vocal';
                } else if (conv.lastMessage.image_url) {
                    lastMsg = 'üì∑ Photo';
                } else {
                    lastMsg = conv.lastMessage.texte?.substring(0, 50) || 'üì∑ Photo';
                }
                const time = formatTime(conv.lastMessage.date_created);
                const isUnread = conv.unread > 0;

                const div = document.createElement('div');
                div.className = 'list-item';
                if (currentChatUser && currentChatUser.user_id === conv.user.user_id) {
                    div.classList.add('active');
                }
                div.onclick = () => {
                    closeConversationsModal();
                    openChat(conv.user);
                };
                div.innerHTML = `
                    <div class="item-avatar">${initials}</div>
                    <div class="item-info">
                        <div class="item-header">
                            <span class="item-name">${conv.user.prenom} ${conv.user.nom}</span>
                            ${conv.user.role === 'admin' ? '<span class="item-role">Admin</span>' : ''}
                            <span class="item-time">${time}</span>
                        </div>
                        <div class="item-preview ${isUnread ? 'unread' : ''}">${lastMsg}</div>
                    </div>
                    ${conv.unread > 0 ? `<div class="item-unread">${conv.unread}</div>` : ''}
                `;
                container.appendChild(div);
            });
        }

        function displayContacts(contacts) {
            const container = document.getElementById('contacts-list');

            if (contacts.length === 0) {
                container.innerHTML = '<div class="loading"><i class="fas fa-user-slash"></i><p>Aucun contact disponible</p></div>';
                return;
            }

            container.innerHTML = '';
            contacts.forEach(user => {
                const initials = `${user.prenom[0]}${user.nom[0]}`.toUpperCase();
                const div = document.createElement('div');
                div.className = 'list-item';
                div.onclick = () => {
                    closeContactsModal();
                    openChat(user);
                };
                div.innerHTML = `
                    <div class="item-avatar">${initials}</div>
                    <div class="item-info">
                        <div class="item-header">
                            <span class="item-name">${user.prenom} ${user.nom}</span>
                            ${user.role === 'admin' ? '<span class="item-role">Admin</span>' : ''}
                        </div>
                        <div class="item-preview">D√©marrer une conversation</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function displayMessages(messages) {
            const container = document.getElementById('chat-messages');
            if (!container) return;

            const shouldScroll = container.scrollHeight - container.scrollTop <= container.clientHeight + 100;
            container.innerHTML = '';

            let currentDate = null;
            let lastSenderId = null;
            let messageGroup = [];

            messages.forEach((msg, index) => {
                const msgDate = new Date(msg.date_created).toDateString();
                
                if (msgDate !== currentDate) {
                    if (messageGroup.length > 0) {
                        displayMessageGroup(container, messageGroup);
                        messageGroup = [];
                    }
                    
                    const separator = document.createElement('div');
                    separator.className = 'date-separator';
                    separator.innerHTML = `<span>${formatDateSeparator(msg.date_created)}</span>`;
                    container.appendChild(separator);
                    currentDate = msgDate;
                    lastSenderId = null;
                }

                if (msg.sender_id !== lastSenderId && messageGroup.length > 0) {
                    displayMessageGroup(container, messageGroup);
                    messageGroup = [];
                }

                messageGroup.push(msg);
                lastSenderId = msg.sender_id;

                if (index === messages.length - 1) {
                    displayMessageGroup(container, messageGroup);
                }
            });

            if (shouldScroll) container.scrollTop = container.scrollHeight;
        }

        function displayMessageGroup(container, messages) {
            if (messages.length === 0) return;

            const groupDiv = document.createElement('div');
            groupDiv.className = 'message-group';

            messages.forEach((msg, index) => {
                const isSent = msg.sender_id === currentUser.id;
                const div = document.createElement('div');
                div.className = `message-bubble ${isSent ? 'message-sent' : 'message-received'}`;
                div.setAttribute('data-message-id', msg.message_id);

                if (messages.length === 1) {
                } else if (index === 0) {
                    div.classList.add('first-in-group');
                } else if (index === messages.length - 1) {
                    div.classList.add('last-in-group');
                } else {
                    div.classList.add('middle-in-group');
                }

                let content = '';
                if (msg.texte) content += `<div class="message-text">${escapeHtml(msg.texte)}</div>`;
                if (msg.image_url) content += `<img src="${msg.image_url}" class="message-image" onclick="openImageFullscreen('${msg.image_url}')">`;
                
                if (msg.audio_url) {
                    content += `
                        <div class="message-audio">
                            <button class="audio-play-btn" onclick="playAudio('${msg.audio_url}', this)">
                                <i class="fas fa-play"></i>
                            </button>
                            <div class="audio-waveform">
                                <div class="audio-duration">üéµ Message vocal</div>
                            </div>
                        </div>
                    `;
                }
                
                if (msg.files && msg.files.length > 0) {
                    msg.files.forEach(file => {
                        const fileIcon = getFileIcon(file.file_type);
                        content += `
                            <div class="message-file" onclick="downloadFile('${file.file_url}', '${file.file_name}')">
                                <div class="file-icon">
                                    <i class="fas ${fileIcon}"></i>
                                </div>
                                <div class="file-info">
                                    <div class="file-name">${escapeHtml(file.file_name)}</div>
                                    <div class="file-meta">
                                        <span>${file.file_type}</span>
                                        <span>${formatFileSize(file.file_size)}</span>
                                    </div>
                                </div>
                                <div class="file-download">
                                    <i class="fas fa-download"></i>
                                </div>
                            </div>
                        `;
                    });
                }
                
                if (index === messages.length - 1) {
                    let statusIcon = '';
                    if (isSent) {
                        if (msg.read_status) {
                            statusIcon = '<span class="message-status"><i class="fas fa-check-double" style="color: #8a9b56;"></i></span>';
                        } else if (msg.delivery_status === 'delivered') {
                            statusIcon = '<span class="message-status"><i class="fas fa-check-double"></i></span>';
                        } else if (msg.delivery_status === 'sent') {
                            statusIcon = '<span class="message-status"><i class="fas fa-check"></i></span>';
                        }
                    }
                    content += `<div class="message-time">${formatMessageTime(msg.date_created)} ${statusIcon}</div>`;
                }

                content += `
                    <div class="reaction-picker">
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', '‚ù§Ô∏è', event)">‚ù§Ô∏è</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üòÇ', event)">üòÇ</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üòÆ', event)">üòÆ</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üò¢', event)">üò¢</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üëç', event)">üëç</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üëé', event)">üëé</div>
                    </div>
                `;

                div.innerHTML = content;
                groupDiv.appendChild(div);
            });

            container.appendChild(groupDiv);
        }

        function showEmptyState(title, subtitle = '') {
            document.getElementById('chat-area').innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-comments"></i>
                    <h3>${title}</h3>
                    ${subtitle ? `<p>${subtitle}</p>` : ''}
                </div>
            `;
        }

        // ==================== CHAT ====================
        function openChat(user) {
            currentChatUser = user;
            selectedImage = null;
            selectedFile = null;
            const initials = `${user.prenom[0]}${user.nom[0]}`.toUpperCase();
            const chatArea = document.getElementById('chat-area');

            const isAdmin = userProfile.role === 'admin';

            chatArea.innerHTML = `
                <div class="chat-header">
                    <div class="chat-avatar">${initials}</div>
                    <div class="chat-user-info">
                        <h3>${user.prenom} ${user.nom}</h3>
                        <p id="user-status">${user.role === 'admin' ? 'Administrateur' : 'Utilisateur'}</p>
                    </div>
                    <div class="chat-header-actions">
                        <button class="chat-header-btn" onclick="refreshChat()" title="Actualiser">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                </div>
                <div class="chat-messages" id="chat-messages"></div>
                <div class="image-preview-container" id="image-preview-container">
                    <div class="image-preview">
                        <img id="preview-image" src="" alt="Preview">
                        <button class="remove-preview" onclick="removeImagePreview()">√ó</button>
                    </div>
                </div>
                <div class="file-preview-container" id="file-preview-container">
                    <div class="file-preview">
                        <div class="file-preview-icon" id="file-preview-icon">
                            <i class="fas fa-file"></i>
                        </div>
                        <div class="file-preview-info">
                            <div class="file-preview-name" id="file-preview-name"></div>
                            <div class="file-preview-size" id="file-preview-size"></div>
                        </div>
                        <button class="remove-file-preview" onclick="removeFilePreview()">√ó</button>
                    </div>
                </div>
                <div class="chat-input-area">
                    <input type="file" id="image-input" accept="image/*" style="display: none;" onchange="handleImageSelect(event)">
                    <input type="file" id="file-input" accept=".pdf,.zip,.mp3,.mp4,.wav,.doc,.docx,.xls,.xlsx" style="display: none;" onchange="handleFileSelect(event)">
                    <div style="position: relative;">
                        <button class="attach-btn" id="attach-btn" onclick="toggleAttachMenu()" title="Joindre un fichier">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <div class="attach-menu" id="attach-menu">
                            <div class="attach-option" onclick="document.getElementById('image-input').click(); document.getElementById('attach-menu').classList.remove('show');">
                                <i class="fas fa-image"></i>
                                <span>Photo</span>
                            </div>
                            <div class="attach-option ${!isAdmin ? 'admin-only' : ''}" onclick="${isAdmin ? "document.getElementById('file-input').click(); document.getElementById('attach-menu').classList.remove('show');" : "alert('Seuls les administrateurs peuvent envoyer des fichiers');"}" title="${!isAdmin ? 'R√©serv√© aux admins' : ''}">
                                <i class="fas fa-file"></i>
                                <span>Fichier ${!isAdmin ? 'üîí' : ''}</span>
                            </div>
                            ${isAdmin ? `<div class="attach-option" onclick="toggleVoiceRecording(); document.getElementById('attach-menu').classList.remove('show');" title="Enregistrement vocal">
                                <i class="fas fa-microphone"></i>
                                <span>Audio vocal üîí</span>
                            </div>` : ''}
                        </div>
                    </div>
                    ${isAdmin ? `<button class="voice-btn" id="voice-btn" onclick="toggleVoiceRecording()" title="Enregistrement vocal">
                        <i class="fas fa-microphone"></i>
                    </button>` : ''}
                    <div class="input-wrapper">
                        <textarea class="message-input" id="message-input" placeholder="Aa" rows="1" oninput="handleInputChange()" onkeydown="handleKeyDown(event)"></textarea>
                        <button class="emoji-btn" onclick="insertEmoji()" title="Emoji">
                            üòä
                        </button>
                    </div>
                    <button class="send-btn" onclick="sendMessage()" id="send-btn" disabled>
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            `;

            loadMessages(user.user_id);
            markMessagesAsRead(user.user_id);
            subscribeToMessages(user.user_id);
            subscribeToTypingStatus(user.user_id);
            subscribeToDeliveryStatus(user.user_id);
            
            const input = document.getElementById('message-input');
            if (input) input.focus();
        }

        // ==================== ENVOI MESSAGES ====================
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const texte = input ? input.value.trim() : '';

            if (!texte && !selectedImage && !selectedFile) return;

            if (sendBtn) {
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            updateTypingStatus(false);

            try {
                let imageUrl = null;
                let messageId = null;

                if (selectedImage) {
                    const fileName = `${Date.now()}_${selectedImage.name}`;
                    const { error: uploadError } = await supabaseInstance.storage
                        .from('messages-images')
                        .upload(fileName, selectedImage, {
                            contentType: selectedImage.type,
                            upsert: false
                        });

                    if (uploadError) throw uploadError;
                    const { data } = supabaseInstance.storage.from('messages-images').getPublicUrl(fileName);
                    imageUrl = data.publicUrl;
                }

                const { data: messageData, error: insertError } = await supabaseInstance
                    .from('messages')
                    .insert({
                        sender_id: currentUser.id,
                        receiver_id: currentChatUser.user_id,
                        texte: texte || null,
                        image_url: imageUrl,
                        audio_url: null,
                        delivery_status: 'sent'
                    })
                    .select()
                    .single();

                if (insertError) throw insertError;
                messageId = messageData.message_id;

                if (selectedFile && userProfile.role === 'admin') {
                    const fileName = `${Date.now()}_${selectedFile.name}`;
                    
                    const { error: fileUploadError } = await supabaseInstance.storage
                        .from('messages-files')
                        .upload(fileName, selectedFile, {
                            contentType: selectedFile.type,
                            upsert: false
                        });

                    if (fileUploadError) throw fileUploadError;
                    
                    const { data: fileUrlData } = supabaseInstance.storage
                        .from('messages-files')
                        .getPublicUrl(fileName);
                    
                    const fileType = getFileTypeFromMime(selectedFile.type, selectedFile.name);
                    
                    const { error: fileMetaError } = await supabaseInstance
                        .from('message_files')
                        .insert({
                            message_id: messageId,
                            file_url: fileUrlData.publicUrl,
                            file_name: selectedFile.name,
                            file_type: fileType,
                            file_size: selectedFile.size,
                            mime_type: selectedFile.type
                        });

                    if (fileMetaError) throw fileMetaError;
                }

                if (input) {
                    input.value = '';
                    input.style.height = 'auto';
                    input.focus();
                }
                
                removeImagePreview();
                removeFilePreview();
                
            } catch (error) {
                console.error('Erreur envoi message:', error);
                alert('Erreur lors de l\'envoi du message. Veuillez r√©essayer.');
            } finally {
                if (sendBtn) {
                    sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                    handleInputChange();
                }
            }
        }

        async function markMessagesAsRead(otherUserId) {
            try {
                await supabaseInstance
                    .from('messages')
                    .update({ 
                        read_status: true, 
                        delivery_status: 'read',
                        read_at: new Date().toISOString()
                    })
                    .eq('sender_id', otherUserId)
                    .eq('receiver_id', currentUser.id)
                    .eq('read_status', false);
                    
                await loadConversations();
            } catch (error) {
                console.error('Erreur marquage lu:', error);
            }
        }

        // ==================== ENREGISTREMENT VOCAL ====================
        async function toggleVoiceRecording() {
            if (userProfile.role !== 'admin') {
                alert('Seuls les administrateurs peuvent envoyer des messages vocaux');
                return;
            }

            if (!isRecording) {
                await startVoiceRecording();
            } else {
                await stopVoiceRecording();
            }
        }

        async function startVoiceRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    await uploadVoiceMessage(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                const voiceBtn = document.getElementById('voice-btn');
                if (voiceBtn) {
                    voiceBtn.classList.add('recording');
                    voiceBtn.innerHTML = '<i class="fas fa-stop"></i>';
                }

                document.getElementById('recording-indicator').classList.add('show');
                recordingTimer = setInterval(updateRecordingTime, 1000);
                
            } catch (error) {
                console.error('Erreur acc√®s microphone:', error);
                alert('Impossible d\'acc√©der au microphone. V√©rifiez les permissions.');
            }
        }

        async function stopVoiceRecording() {
            if (!mediaRecorder || !isRecording) return;

            mediaRecorder.stop();
            isRecording = false;
            
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }

            const voiceBtn = document.getElementById('voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.remove('recording');
                voiceBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            }

            document.getElementById('recording-indicator').classList.remove('show');
        }

        function updateRecordingTime() {
            if (!recordingStartTime) return;
            
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            const timeDisplay = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recording-time').textContent = timeDisplay;
        }

        async function uploadVoiceMessage(audioBlob) {
            try {
                const fileName = `voice_${Date.now()}_${currentUser.id}.wav`;
                
                const { error: uploadError } = await supabaseInstance.storage
                    .from('messages-files')
                    .upload(fileName, audioBlob, {
                        contentType: 'audio/wav',
                        upsert: false
                    });

                if (uploadError) throw uploadError;
                
                const { data: audioUrlData } = supabaseInstance.storage
                    .from('messages-files')
                    .getPublicUrl(fileName);

                const { data: messageData, error: insertError } = await supabaseInstance
                    .from('messages')
                    .insert({
                        sender_id: currentUser.id,
                        receiver_id: currentChatUser.user_id,
                        texte: null,
                        image_url: null,
                        audio_url: audioUrlData.publicUrl,
                        delivery_status: 'sent'
                    })
                    .select()
                    .single();

                if (insertError) throw insertError;
                console.log('Message vocal envoy√© avec succ√®s');
                
            } catch (error) {
                console.error('Erreur envoi message vocal:', error);
                alert('Erreur lors de l\'envoi du message vocal');
            }
        }

        // ==================== SUBSCRIPTIONS ====================
        function subscribeToMessages(otherUserId) {
            if (messageSubscription) supabaseInstance.removeChannel(messageSubscription);

            messageSubscription = supabaseInstance.channel(`chat-${currentUser.id}-${otherUserId}`)
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'messages'
                }, async (payload) => {
                    if ((payload.new.sender_id === otherUserId && payload.new.receiver_id === currentUser.id) ||
                        (payload.new.sender_id === currentUser.id && payload.new.receiver_id === otherUserId)) {
                        
                        const { data: files } = await supabaseInstance
                            .from('message_files')
                            .select('*')
                            .eq('message_id', payload.new.message_id);
                        
                        payload.new.files = files || [];
                        messagesCache.push(payload.new);
                        displayMessages(messagesCache);
                        
                        if (payload.new.receiver_id === currentUser.id) {
                            markMessagesAsRead(otherUserId);
                        }
                        
                        loadConversations();
                    }
                })
                .subscribe();
        }

        async function updateTypingStatus(typing) {
            if (!currentChatUser) return;
            isTyping = typing;
            
            try {
                if (typing) {
                    await supabaseInstance
                        .from('typing_status')
                        .upsert({
                            user_id: currentUser.id,
                            chat_with_user_id: currentChatUser.user_id,
                            is_typing: true
                        });
                } else {
                    await supabaseInstance
                        .from('typing_status')
                        .delete()
                        .eq('user_id', currentUser.id)
                        .eq('chat_with_user_id', currentChatUser.user_id);
                }
            } catch (error) {
                console.error('Erreur typing status:', error);
            }
        }

        function subscribeToTypingStatus(otherUserId) {
            if (typingSubscription) supabaseInstance.removeChannel(typingSubscription);

            typingSubscription = supabaseInstance.channel(`typing-${currentUser.id}-${otherUserId}`)
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'typing_status',
                    filter: `user_id=eq.${otherUserId}`
                }, (payload) => {
                    const statusEl = document.getElementById('user-status');
                    if (!statusEl) return;
                    
                    if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                        if (payload.new.is_typing && payload.new.chat_with_user_id === currentUser.id) {
                            statusEl.innerHTML = '<span class="typing-indicator">En train d\'√©crire<span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
                        }
                    } else if (payload.eventType === 'DELETE') {
                        statusEl.textContent = currentChatUser.role === 'admin' ? 'Administrateur' : 'Utilisateur';
                    }
                })
                .subscribe();
        }

        function subscribeToDeliveryStatus(otherUserId) {
            if (deliverySubscription) supabaseInstance.removeChannel(deliverySubscription);

            deliverySubscription = supabaseInstance.channel(`delivery-${currentUser.id}-${otherUserId}`)
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'messages',
                    filter: `sender_id=eq.${currentUser.id}`
                }, (payload) => {
                    updateMessageStatus(payload.new.message_id, payload.new.delivery_status, payload.new.read_status);
                })
                .subscribe();
        }

        function updateMessageStatus(messageId, deliveryStatus, readStatus) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageEl) return;

            const statusEl = messageEl.querySelector('.message-status');
            if (!statusEl) return;

            if (readStatus) {
                statusEl.innerHTML = '<i class="fas fa-check-double" style="color: #8a9b56;"></i>';
            } else if (deliveryStatus === 'delivered') {
                statusEl.innerHTML = '<i class="fas fa-check-double"></i>';
            } else if (deliveryStatus === 'sent') {
                statusEl.innerHTML = '<i class="fas fa-check"></i>';
            }
        }

        // ==================== GESTION FICHIERS ====================
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 5000000) {
                alert('L\'image est trop volumineuse (max 5MB)');
                return;
            }

            selectedImage = file;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const previewContainer = document.getElementById('image-preview-container');
                const previewImage = document.getElementById('preview-image');
                if (previewContainer && previewImage) {
                    previewImage.src = e.target.result;
                    previewContainer.style.display = 'block';
                    handleInputChange();
                }
            };
            reader.readAsDataURL(file);
        }

        function removeImagePreview() {
            selectedImage = null;
            const previewContainer = document.getElementById('image-preview-container');
            const imageInput = document.getElementById('image-input');
            if (previewContainer) previewContainer.style.display = 'none';
            if (imageInput) imageInput.value = '';
            handleInputChange();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (userProfile.role !== 'admin') {
                alert('Seuls les administrateurs peuvent envoyer des fichiers');
                event.target.value = '';
                return;
            }

            if (file.size > 50000000) {
                alert('Le fichier est trop volumineux (max 50MB)');
                return;
            }

            selectedFile = file;
            
            const previewContainer = document.getElementById('file-preview-container');
            const previewName = document.getElementById('file-preview-name');
            const previewSize = document.getElementById('file-preview-size');
            const previewIcon = document.getElementById('file-preview-icon');
            
            if (previewName) previewName.textContent = file.name;
            if (previewSize) previewSize.textContent = formatFileSize(file.size);
            
            const fileType = getFileTypeFromMime(file.type, file.name);
            const iconClass = getFileIcon(fileType);
            if (previewIcon) previewIcon.innerHTML = `<i class="fas ${iconClass}"></i>`;
            
            if (previewContainer) previewContainer.style.display = 'block';
            handleInputChange();
        }

        function removeFilePreview() {
            selectedFile = null;
            const previewContainer = document.getElementById('file-preview-container');
            const fileInput = document.getElementById('file-input');
            if (previewContainer) previewContainer.style.display = 'none';
            if (fileInput) fileInput.value = '';
            handleInputChange();
        }

        function playAudio(audioUrl, button) {
            const audio = new Audio(audioUrl);
            const icon = button.querySelector('i');
            
            if (!icon) return;
            
            icon.className = 'fas fa-spinner fa-spin';
            
            audio.onloadeddata = () => {
                icon.className = 'fas fa-pause';
                audio.play();
            };
            
            audio.onended = () => {
                icon.className = 'fas fa-play';
            };
            
            audio.onerror = () => {
                icon.className = 'fas fa-exclamation-triangle';
                alert('Erreur lors de la lecture du message vocal');
            };
            
            if (!audio.paused) {
                audio.pause();
                icon.className = 'fas fa-play';
            }
        }

        async function downloadFile(fileUrl, fileName) {
            try {
                const response = await fetch(fileUrl);
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Erreur t√©l√©chargement fichier:', error);
                alert('Erreur lors du t√©l√©chargement du fichier');
            }
        }

        // ==================== MODALES ====================
        function openConversationsModal() {
            displayConversations(conversationsCache);
            document.getElementById('conversations-modal').classList.add('show');
        }

        function closeConversationsModal() {
            document.getElementById('conversations-modal').classList.remove('show');
        }

        async function openContactsModal() {
            if (contactsCache.length === 0) {
                document.getElementById('contacts-list').innerHTML = '<div class="loading"><i class="fas fa-spinner fa-spin"></i><p>Chargement...</p></div>';
                document.getElementById('contacts-modal').classList.add('show');
                await loadContacts();
                displayContacts(contactsCache);
            } else {
                displayContacts(contactsCache);
                document.getElementById('contacts-modal').classList.add('show');
            }
        }

        function closeContactsModal() {
            document.getElementById('contacts-modal').classList.remove('show');
        }

        function filterList(type, query) {
            const data = type === 'conversations' ? conversationsCache : contactsCache;
            const filtered = data.filter(item => {
                const user = item.user || item;
                return `${user.prenom} ${user.nom}`.toLowerCase().includes(query.toLowerCase());
            });

            if (type === 'conversations') {
                displayConversations(filtered);
            } else {
                displayContacts(filtered);
            }
        }

        // ==================== INPUT HANDLERS ====================
        function toggleAttachMenu() {
            const menu = document.getElementById('attach-menu');
            if (menu) {
                menu.classList.toggle('show');
            }
        }

        function handleInputChange() {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            
            if (!input || !sendBtn) return;
            
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 100) + 'px';
            
            const hasContent = input.value.trim().length > 0 || selectedImage !== null || selectedFile !== null;
            sendBtn.disabled = !hasContent;
            
            if (input.value.trim().length > 0 && !isTyping) {
                updateTypingStatus(true);
            }
            
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                updateTypingStatus(false);
            }, 2000);
        }

        function handleKeyDown(event) {
            // Enter = nouvelle ligne (comportement par d√©faut)
        }

        function insertEmoji() {
            const emojis = ['üòä', 'üòÇ', '‚ù§Ô∏è', 'üëç', 'üéâ', 'üî•', 'üòç', 'ü§î', 'üëè', 'üôè'];
            const emoji = emojis[Math.floor(Math.random() * emojis.length)];
            const input = document.getElementById('message-input');
            if (input) {
                input.value += emoji;
                input.focus();
                handleInputChange();
            }
        }

        function openImageFullscreen(imageUrl) {
            window.open(imageUrl, '_blank');
        }

        async function addReaction(messageId, emoji, event) {
            event.stopPropagation();
            console.log('R√©action ajout√©e:', emoji, 'au message', messageId);
        }

        function refreshChat() {
            if (currentChatUser) {
                loadMessages(currentChatUser.user_id);
                loadConversations();
            }
        }

        // ==================== UTILITAIRES ====================
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/\n/g, '<br>');
        }

        function formatFileSize(bytes) {
            if (!bytes) return 'Taille inconnue';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function getFileIcon(fileType) {
            const icons = {
                'video': 'fa-file-video',
                'audio': 'fa-file-audio',
                'pdf': 'fa-file-pdf',
                'zip': 'fa-file-archive',
                'document': 'fa-file-word',
                'other': 'fa-file'
            };
            return icons[fileType] || 'fa-file';
        }

        function getFileTypeFromMime(mimeType, fileName) {
            if (mimeType.startsWith('video/')) return 'video';
            if (mimeType.startsWith('audio/')) return 'audio';
            if (mimeType === 'application/pdf') return 'pdf';
            if (mimeType === 'application/zip' || mimeType === 'application/x-zip-compressed') return 'zip';
            if (mimeType.includes('word') || fileName.endsWith('.doc') || fileName.endsWith('.docx')) return 'document';
            if (mimeType.includes('excel') || fileName.endsWith('.xls') || fileName.endsWith('.xlsx')) return 'document';
            return 'other';
        }

        function formatTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;

            if (diff < 60000) return '√Ä l\'instant';
            if (diff < 3600000) return `${Math.floor(diff / 60000)} min`;
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            }
            
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'Hier';
            }
            
            return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
        }

        function formatMessageTime(dateString) {
            const date = new Date(dateString);
            return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDateSeparator(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            
            if (date.toDateString() === now.toDateString()) {
                return 'Aujourd\'hui';
            }
            
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'Hier';
            }
            
            return date.toLocaleDateString('fr-FR', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
        }

        // ==================== EVENT LISTENERS ====================
        document.getElementById('conversations-modal').addEventListener('click', function(e) {
            if (e.target === this) closeConversationsModal();
        });

        document.getElementById('contacts-modal').addEventListener('click', function(e) {
            if (e.target === this) closeContactsModal();
        });

        window.addEventListener('beforeunload', () => {
            updateTypingStatus(false);
            if (mediaRecorder && isRecording) {
                stopVoiceRecording();
            }
            if (messageSubscription) supabaseInstance.removeChannel(messageSubscription);
            if (typingSubscription) supabaseInstance.removeChannel(typingSubscription);
            if (deliverySubscription) supabaseInstance.removeChannel(deliverySubscription);
        });

        setInterval(() => {
            if (!document.hidden && currentUser) {
                loadConversations();
            }
        }, 30000);
    </script>
</body>
</html>
