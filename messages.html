<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Connect - Messages</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="messages.css">
</head>
<body>
    <canvas id="three-canvas"></canvas>
    
    <div class="messages-wrapper">
        <div class="messages-header">
            <h1><i class="fas fa-globe"></i> <span id="header-title">World Connect</span></h1>
            <div class="header-actions">
                <button class="action-btn secondary" onclick="openConversationsModal()">
                    <i class="fas fa-list"></i>
                    <span>Conversations</span>
                </button>
                <button class="action-btn" onclick="openContactsModal()">
                    <i class="fas fa-user-plus"></i>
                    <span id="contacts-btn-text">Contacts</span>
                </button>
            </div>
        </div>

        <div class="messages-container">
            <div class="chat-area" id="chat-area">
                <div class="empty-state">
                    <i class="fas fa-spinner fa-spin"></i>
                    <h3>Chargement...</h3>
                </div>
            </div>
        </div>
    </div>

    <!-- Voice recording indicator -->
    <div class="recording-indicator" id="recording-indicator">
        <div class="recording-wave">
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
        </div>
        <div class="recording-time" id="recording-time">00:00</div>
        <div class="recording-text">üé§ Enregistrement vocal en cours...<br>Cliquez √† nouveau pour arr√™ter</div>
    </div>

    <!-- Modal Conversations -->
    <div class="modal" id="conversations-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-comments"></i> Conversations r√©centes</h3>
                <button class="close-modal" onclick="closeConversationsModal()">√ó</button>
            </div>
            <div class="modal-search">
                <input type="text" placeholder="Rechercher une conversation..." id="search-conversations">
            </div>
            <div class="list-container" id="conversations-list"></div>
        </div>
    </div>

    <!-- Modal Contacts -->
    <div class="modal" id="contacts-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-address-book"></i> <span id="contacts-modal-title">Contacts</span></h3>
                <button class="close-modal" onclick="closeContactsModal()">√ó</button>
            </div>
            <div class="modal-search">
                <input type="text" placeholder="Rechercher un contact..." id="search-contacts">
            </div>
            <div class="list-container" id="contacts-list"></div>
        </div>
    </div>

    <script src="supabaseClient.js"></script>
    <script>
        // ==================== THREE.JS ANIMATION ====================
        const canvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        camera.position.z = 50;

        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 3000;
        const posArray = new Float32Array(particlesCount * 3);
        
        for(let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 150;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.3,
            color: 0x4a90e2,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        const linesGroup = new THREE.Group();
        scene.add(linesGroup);
        
        function createConnectionLines() {
            for(let i = 0; i < 80; i++) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                
                positions[0] = (Math.random() - 0.5) * 100;
                positions[1] = (Math.random() - 0.5) * 100;
                positions[2] = (Math.random() - 0.5) * 100;
                positions[3] = (Math.random() - 0.5) * 100;
                positions[4] = (Math.random() - 0.5) * 100;
                positions[5] = (Math.random() - 0.5) * 100;
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: 0x3a7bc8,
                    transparent: true,
                    opacity: 0.2
                });
                
                const line = new THREE.Line(geometry, material);
                linesGroup.add(line);
            }
        }
        
        createConnectionLines();

        const sphereGeometry = new THREE.SphereGeometry(8, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0x2e5c8a,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.001;
            
            particlesMesh.rotation.y = time * 0.3;
            particlesMesh.rotation.x = time * 0.2;
            sphere.rotation.y = time * 0.5;
            sphere.rotation.x = time * 0.3;
            linesGroup.rotation.y = time * 0.2;
            linesGroup.rotation.z = time * 0.1;
            particlesMaterial.opacity = 0.5 + Math.sin(time * 2) * 0.3;
            
            renderer.render(scene, camera);
        }
        
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== VARIABLES GLOBALES ====================
        let supabaseInstance, getCurrentUser, getUserProfile, redirectByRole;
        let currentUser = null;
        let userProfile = null;
        let currentChatUser = null;
        let messageSubscription = null;
        let typingSubscription = null;
        let deliverySubscription = null;
        let reactionSubscription = null;
        let conversationsCache = [];
        let contactsCache = [];
        let typingTimeout = null;
        let isTyping = false;
        let selectedImage = null;
        let selectedFile = null;
        let messagesCache = [];
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimer = null;
        let userVoicePermission = false;

        // ==================== INITIALISATION ====================
        function initializeApp() {
            if (window.supabaseClient && window.supabaseClient.supabase) {
                supabaseInstance = window.supabaseClient.supabase;
                getCurrentUser = window.supabaseClient.getCurrentUser;
                getUserProfile = window.supabaseClient.getUserProfile;
                redirectByRole = window.supabaseClient.redirectByRole;
                
                console.log('‚úÖ Supabase initialis√©:', !!supabaseInstance);
                
                initApp();
            } else {
                console.warn('‚è≥ En attente de supabaseClient...');
                setTimeout(initializeApp, 100);
            }
        }

        async function initApp() {
            if (!supabaseInstance) {
                console.error('‚ùå supabaseInstance non initialis√©');
                alert('Erreur: Client Supabase non initialis√©. Rechargez la page.');
                return;
            }

            currentUser = await getCurrentUser();
            if (!currentUser) {
                console.warn('‚ùå Utilisateur non connect√©, redirection...');
                window.location.href = 'connexion.html';
                return;
            }

            console.log('‚úÖ Utilisateur connect√©:', currentUser.id);

            userProfile = await getUserProfile(currentUser.id);
            if (!userProfile) {
                console.error('‚ùå Profil utilisateur introuvable');
                alert('Erreur: Profil introuvable. Veuillez vous reconnecter.');
                window.location.href = 'connexion.html';
                return;
            }

            console.log('‚úÖ Profil charg√©:', userProfile);
            
            // ‚úÖ Charger les permissions vocales
            await loadVoicePermission();
            
            await initInterface();

            document.getElementById('search-conversations').addEventListener('input', (e) => filterList('conversations', e.target.value));
            document.getElementById('search-contacts').addEventListener('input', (e) => filterList('contacts', e.target.value));
            
            document.addEventListener('click', (e) => {
                const menu = document.getElementById('attach-menu');
                const btn = document.getElementById('attach-btn');
                if (menu && !menu.contains(e.target) && !btn.contains(e.target)) {
                    menu.classList.remove('show');
                }
            });
        }

        window.addEventListener('DOMContentLoaded', initializeApp);

        // ==================== PERMISSIONS VOCALES ====================
        async function loadVoicePermission() {
            try {
                // Admins ont toujours la permission
                if (userProfile.role === 'admin') {
                    userVoicePermission = true;
                    console.log('‚úÖ Admin: permission vocale activ√©e');
                    return;
                }

                // V√©rifier la permission pour les users
                const { data, error } = await supabaseInstance
                    .from('user_voice_permissions')
                    .select('voice_enabled')
                    .eq('user_id', currentUser.id)
                    .single();

                if (error && error.code !== 'PGRST116') {
                    console.error('‚ùå Erreur chargement permissions:', error);
                    userVoicePermission = false;
                    return;
                }

                userVoicePermission = data?.voice_enabled || false;
                console.log('‚úÖ Permission vocale:', userVoicePermission);

            } catch (error) {
                console.error('‚ùå Erreur loadVoicePermission:', error);
                userVoicePermission = false;
            }
        }

        async function toggleUserVoicePermission(userId, enable) {
            if (userProfile.role !== 'admin') {
                alert('Seuls les administrateurs peuvent g√©rer les permissions');
                return;
            }

            try {
                const { error } = await supabaseInstance
                    .from('user_voice_permissions')
                    .upsert({
                        user_id: userId,
                        voice_enabled: enable
                    }, {
                        onConflict: 'user_id'
                    });

                if (error) throw error;

                alert(`Permission vocale ${enable ? 'activ√©e' : 'd√©sactiv√©e'} avec succ√®s`);
                
                // Si c'est pour l'utilisateur actuel, recharger
                if (userId === currentChatUser?.user_id) {
                    await refreshChatInterface();
                }

            } catch (error) {
                console.error('‚ùå Erreur modification permission:', error);
                alert('Erreur lors de la modification de la permission');
            }
        }

        async function refreshChatInterface() {
            if (currentChatUser) {
                const user = currentChatUser;
                currentChatUser = null;
                await openChat(user);
            }
        }

        // ==================== R√âACTIONS ====================
        async function addReaction(messageId, emoji, event) {
            event.stopPropagation();
            
            try {
                // V√©rifier si l'utilisateur a d√©j√† r√©agi
                const { data: existing } = await supabaseInstance
                    .from('message_reactions')
                    .select('id, emoji')
                    .eq('message_id', messageId)
                    .eq('user_id', currentUser.id)
                    .single();

                if (existing) {
                    if (existing.emoji === emoji) {
                        // Supprimer la r√©action si c'est la m√™me
                        await supabaseInstance
                            .from('message_reactions')
                            .delete()
                            .eq('id', existing.id);
                        console.log('‚úÖ R√©action supprim√©e');
                    } else {
                        // Modifier la r√©action
                        await supabaseInstance
                            .from('message_reactions')
                            .update({ emoji: emoji })
                            .eq('id', existing.id);
                        console.log('‚úÖ R√©action modifi√©e');
                    }
                } else {
                    // Ajouter une nouvelle r√©action
                    const { error } = await supabaseInstance
                        .from('message_reactions')
                        .insert({
                            message_id: messageId,
                            user_id: currentUser.id,
                            emoji: emoji
                        });

                    if (error) throw error;
                    console.log('‚úÖ R√©action ajout√©e');
                }

                // Recharger les r√©actions pour ce message
                await loadMessageReactions(messageId);

            } catch (error) {
                console.error('‚ùå Erreur ajout r√©action:', error);
            }
        }

        async function loadMessageReactions(messageId) {
            try {
                const { data, error } = await supabaseInstance
                    .from('message_reactions')
                    .select('emoji, user_id')
                    .eq('message_id', messageId);

                if (error) throw error;

                // Grouper les r√©actions par emoji
                const reactions = {};
                data.forEach(r => {
                    if (!reactions[r.emoji]) {
                        reactions[r.emoji] = {
                            count: 0,
                            users: [],
                            hasCurrentUser: false
                        };
                    }
                    reactions[r.emoji].count++;
                    reactions[r.emoji].users.push(r.user_id);
                    if (r.user_id === currentUser.id) {
                        reactions[r.emoji].hasCurrentUser = true;
                    }
                });

                // Mettre √† jour l'affichage
                displayMessageReactions(messageId, reactions);

            } catch (error) {
                console.error('‚ùå Erreur chargement r√©actions:', error);
            }
        }

        function displayMessageReactions(messageId, reactions) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageEl) return;

            // Supprimer les anciennes r√©actions
            const oldReactions = messageEl.querySelector('.message-reactions');
            if (oldReactions) oldReactions.remove();

            // Si pas de r√©actions, ne rien afficher
            if (Object.keys(reactions).length === 0) return;

            // Cr√©er le container de r√©actions
            const reactionsDiv = document.createElement('div');
            reactionsDiv.className = 'message-reactions';

            Object.entries(reactions).forEach(([emoji, data]) => {
                const reactionSpan = document.createElement('span');
                reactionSpan.className = 'reaction-item' + (data.hasCurrentUser ? ' user-reacted' : '');
                reactionSpan.innerHTML = `${emoji} ${data.count}`;
                reactionSpan.onclick = (e) => addReaction(messageId, emoji, e);
                reactionsDiv.appendChild(reactionSpan);
            });

            messageEl.appendChild(reactionsDiv);
        }

        function subscribeToReactions() {
            if (reactionSubscription) supabaseInstance.removeChannel(reactionSubscription);

            reactionSubscription = supabaseInstance.channel('message-reactions')
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'message_reactions'
                }, (payload) => {
                    const messageId = payload.new?.message_id || payload.old?.message_id;
                    if (messageId) {
                        loadMessageReactions(messageId);
                    }
                })
                .subscribe();
        }

        async function initInterface() {
            if (userProfile.role === 'user') {
                document.getElementById('contacts-btn-text').textContent = 'Admins';
                document.getElementById('contacts-modal-title').textContent = 'Administrateurs';
                await initUserChat();
            } else {
                document.getElementById('contacts-btn-text').textContent = 'Contacts';
                document.getElementById('contacts-modal-title').textContent = 'Tous les contacts';
                await initAdminChat();
            }

            // ‚úÖ S'abonner aux r√©actions
            subscribeToReactions();
        }

        async function initUserChat() {
            const storedAdminId = localStorage.getItem(`default_admin_${currentUser.id}`);
            let defaultAdmin = null;

            if (storedAdminId) {
                const { data } = await supabaseInstance
                    .from('users_profile')
                    .select('*')
                    .eq('user_id', storedAdminId)
                    .eq('role', 'admin')
                    .single();
                defaultAdmin = data;
            }

            if (!defaultAdmin) {
                const { data: admins } = await supabaseInstance
                    .from('users_profile')
                    .select('user_id, prenom, nom, role')
                    .eq('role', 'admin')
                    .limit(10);

                if (admins && admins.length > 0) {
                    defaultAdmin = admins[Math.floor(Math.random() * admins.length)];
                    localStorage.setItem(`default_admin_${currentUser.id}`, defaultAdmin.user_id);
                }
            }

            if (defaultAdmin) {
                openChat(defaultAdmin);
            } else {
                showEmptyState('Aucun administrateur disponible', 'Veuillez r√©essayer plus tard');
            }

            await loadConversations();
        }

        async function initAdminChat() {
            await loadConversations();
            
            if (conversationsCache.length > 0) {
                openChat(conversationsCache[0].user);
            } else {
                showEmptyState('Aucune conversation', 'Attendez qu\'un utilisateur vous contacte');
            }
        }

        // ==================== CHARGEMENT DONN√âES ====================
        async function loadConversations() {
            try {
                const [sentMessages, receivedMessages] = await Promise.all([
                    supabaseInstance
                        .from('messages')
                        .select('message_id, sender_id, receiver_id, texte, image_url, date_created, read_status, delivery_status')
                        .eq('sender_id', currentUser.id)
                        .order('date_created', { ascending: false })
                        .limit(100),
                    supabaseInstance
                        .from('messages')
                        .select('message_id, sender_id, receiver_id, texte, image_url, date_created, read_status, delivery_status')
                        .eq('receiver_id', currentUser.id)
                        .order('date_created', { ascending: false })
                        .limit(100)
                ]);

                if (sentMessages.error) throw sentMessages.error;
                if (receivedMessages.error) throw receivedMessages.error;

                const messages = [...(sentMessages.data || []), ...(receivedMessages.data || [])]
                    .sort((a, b) => new Date(b.date_created) - new Date(a.date_created));

                const userIds = new Set();
                messages.forEach(msg => {
                    const otherId = msg.sender_id === currentUser.id ? msg.receiver_id : msg.sender_id;
                    userIds.add(otherId);
                });

                if (userIds.size === 0) {
                    conversationsCache = [];
                    return;
                }

                const { data: users, error: usersError } = await supabaseInstance
                    .from('users_profile')
                    .select('user_id, prenom, nom, role')
                    .in('user_id', Array.from(userIds));

                if (usersError) throw usersError;

                const usersMap = {};
                users.forEach(u => { usersMap[u.user_id] = u; });

                const conversations = {};
                messages.forEach(msg => {
                    const otherId = msg.sender_id === currentUser.id ? msg.receiver_id : msg.sender_id;
                    const otherUser = usersMap[otherId];

                    if (!otherUser) return;
                    if (userProfile.role === 'user' && otherUser.role !== 'admin') return;

                    if (!conversations[otherId]) {
                        conversations[otherId] = {
                            user: otherUser,
                            lastMessage: msg,
                            unread: 0
                        };
                    }
                    if (msg.receiver_id === currentUser.id && !msg.read_status) {
                        conversations[otherId].unread++;
                    }
                });

                conversationsCache = Object.values(conversations).sort((a, b) =>
                    new Date(b.lastMessage.date_created) - new Date(a.lastMessage.date_created)
                );

            } catch (error) {
                console.error('Erreur chargement conversations:', error);
                conversationsCache = [];
            }
        }

        async function loadMessages(otherUserId) {
            try {
                console.log('üîç Chargement messages avec:', otherUserId);
                
                const [sentMessages, receivedMessages] = await Promise.all([
                    supabaseInstance
                        .from('messages')
                        .select('message_id, sender_id, texte, image_url, date_created, delivery_status, read_status')
                        .eq('sender_id', currentUser.id)
                        .eq('receiver_id', otherUserId)
                        .order('date_created', { ascending: true })
                        .limit(100),
                    supabaseInstance
                        .from('messages')
                        .select('message_id, sender_id, texte, image_url, date_created, delivery_status, read_status')
                        .eq('sender_id', otherUserId)
                        .eq('receiver_id', currentUser.id)
                        .order('date_created', { ascending: true })
                        .limit(100)
                ]);

                if (sentMessages.error) throw sentMessages.error;
                if (receivedMessages.error) throw receivedMessages.error;

                messagesCache = [...(sentMessages.data || []), ...(receivedMessages.data || [])]
                    .sort((a, b) => new Date(a.date_created) - new Date(b.date_created));
                
                console.log('‚úÖ Total messages:', messagesCache.length);
                
                if (messagesCache.length > 0) {
                    const messageIds = messagesCache.map(m => m.message_id);
                    
                    const { data: files, error: filesError } = await supabaseInstance
                        .from('message_files')
                        .select('*')
                        .in('message_id', messageIds);
                    
                    if (filesError) {
                        console.error('‚ö†Ô∏è Erreur chargement fichiers:', filesError);
                    } else {
                        console.log('üìé Fichiers charg√©s:', files?.length || 0);
                        if (files) {
                            messagesCache.forEach(msg => {
                                msg.files = files.filter(f => f.message_id === msg.message_id);
                            });
                        }
                    }

                    // ‚úÖ Charger les r√©actions pour tous les messages
                    for (const msg of messagesCache) {
                        await loadMessageReactions(msg.message_id);
                    }
                }
                
                console.log('‚úÖ Affichage des messages...');
                displayMessages(messagesCache);
                
            } catch (error) {
                console.error('‚ùå Erreur compl√®te chargement messages:', error);
                messagesCache = [];
                showEmptyState('Erreur de chargement', 'Impossible de charger les messages');
            }
        }

        async function loadContacts() {
            try {
                const role = userProfile.role === 'user' ? 'admin' : null;
                let query = supabaseInstance
                    .from('users_profile')
                    .select('user_id, prenom, nom, role')
                    .neq('user_id', currentUser.id)
                    .order('prenom')
                    .limit(100);

                if (role) {
                    query = query.eq('role', role);
                }

                const { data, error } = await query;
                if (error) throw error;
                contactsCache = data || [];
            } catch (error) {
                console.error('Erreur chargement contacts:', error);
                contactsCache = [];
            }
        }

        // ==================== AFFICHAGE ====================
        function displayConversations(conversations) {
            const container = document.getElementById('conversations-list');

            if (conversations.length === 0) {
                container.innerHTML = '<div class="loading"><i class="fas fa-inbox"></i><p>Aucune conversation</p></div>';
                return;
            }

            container.innerHTML = '';
            conversations.forEach(conv => {
                const initials = `${conv.user.prenom[0]}${conv.user.nom[0]}`.toUpperCase();
                let lastMsg;
                
                if (conv.lastMessage.files && conv.lastMessage.files.length > 0) {
                    const firstFile = conv.lastMessage.files[0];
                    if (firstFile.file_type === 'audio') {
                        lastMsg = 'üéµ Message vocal';
                    } else if (firstFile.file_type === 'video') {
                        lastMsg = 'üé• Vid√©o';
                    } else if (firstFile.file_type === 'pdf') {
                        lastMsg = 'üìÑ PDF';
                    } else {
                        lastMsg = 'üìé Fichier';
                    }
                } else if (conv.lastMessage.image_url) {
                    lastMsg = 'üì∑ Photo';
                } else {
                    lastMsg = conv.lastMessage.texte?.substring(0, 50) || 'üìé Fichier';
                }
                
                const time = formatTime(conv.lastMessage.date_created);
                const isUnread = conv.unread > 0;

                const div = document.createElement('div');
                div.className = 'list-item';
                if (currentChatUser && currentChatUser.user_id === conv.user.user_id) {
                    div.classList.add('active');
                }
                div.onclick = () => {
                    closeConversationsModal();
                    openChat(conv.user);
                };
                div.innerHTML = `
                    <div class="item-avatar">${initials}</div>
                    <div class="item-info">
                        <div class="item-header">
                            <span class="item-name">${conv.user.prenom} ${conv.user.nom}</span>
                            ${conv.user.role === 'admin' ? '<span class="item-role">Admin</span>' : ''}
                            <span class="item-time">${time}</span>
                        </div>
                        <div class="item-preview ${isUnread ? 'unread' : ''}">${lastMsg}</div>
                    </div>
                    ${conv.unread > 0 ? `<div class="item-unread">${conv.unread}</div>` : ''}
                `;
                container.appendChild(div);
            });
        }

        function displayContacts(contacts) {
            const container = document.getElementById('contacts-list');

            if (contacts.length === 0) {
                container.innerHTML = '<div class="loading"><i class="fas fa-user-slash"></i><p>Aucun contact disponible</p></div>';
                return;
            }

            container.innerHTML = '';
            contacts.forEach(user => {
                const prenom = user.prenom || 'U';
                const nom = user.nom || 'ser';
                const initials = `${prenom[0]}${nom[0]}`.toUpperCase();
                
                const div = document.createElement('div');
                div.className = 'list-item';
                div.onclick = () => {
                    closeContactsModal();
                    openChat(user);
                };
                div.innerHTML = `
                    <div class="item-avatar">${initials}</div>
                    <div class="item-info">
                        <div class="item-header">
                            <span class="item-name">${prenom} ${nom}</span>
                            ${user.role === 'admin' ? '<span class="item-role">Admin</span>' : ''}
                        </div>
                        <div class="item-preview">D√©marrer une conversation</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function displayMessages(messages) {
            const container = document.getElementById('chat-messages');
            if (!container) return;

            const shouldScroll = container.scrollHeight - container.scrollTop <= container.clientHeight + 100;
            container.innerHTML = '';

            let currentDate = null;
            let lastSenderId = null;
            let messageGroup = [];

            messages.forEach((msg, index) => {
                const msgDate = new Date(msg.date_created).toDateString();
                
                if (msgDate !== currentDate) {
                    if (messageGroup.length > 0) {
                        displayMessageGroup(container, messageGroup);
                        messageGroup = [];
                    }
                    
                    const separator = document.createElement('div');
                    separator.className = 'date-separator';
                    separator.innerHTML = `<span>${formatDateSeparator(msg.date_created)}</span>`;
                    container.appendChild(separator);
                    currentDate = msgDate;
                    lastSenderId = null;
                }

                if (msg.sender_id !== lastSenderId && messageGroup.length > 0) {
                    displayMessageGroup(container, messageGroup);
                    messageGroup = [];
                }

                messageGroup.push(msg);
                lastSenderId = msg.sender_id;

                if (index === messages.length - 1) {
                    displayMessageGroup(container, messageGroup);
                }
            });

            if (shouldScroll) container.scrollTop = container.scrollHeight;
        }

        function displayMessageGroup(container, messages) {
            if (messages.length === 0) return;

            const groupDiv = document.createElement('div');
            groupDiv.className = 'message-group';

            messages.forEach((msg, index) => {
                const isSent = msg.sender_id === currentUser.id;
                const div = document.createElement('div');
                div.className = `message-bubble ${isSent ? 'message-sent' : 'message-received'}`;
                div.setAttribute('data-message-id', msg.message_id);

                if (messages.length === 1) {
                } else if (index === 0) {
                    div.classList.add('first-in-group');
                } else if (index === messages.length - 1) {
                    div.classList.add('last-in-group');
                } else {
                    div.classList.add('middle-in-group');
                }

                let content = '';
                if (msg.texte) content += `<div class="message-text">${escapeHtml(msg.texte)}</div>`;
                if (msg.image_url) content += `<img src="${msg.image_url}" class="message-image" onclick="openImageFullscreen('${msg.image_url}')">`;
                
                if (msg.files && msg.files.length > 0) {
                    msg.files.forEach(file => {
                        if (file.file_type === 'audio') {
                            content += `
                                <div class="message-audio">
                                    <button class="audio-play-btn" onclick="playAudio('${file.file_url}', this)">
                                        <i class="fas fa-play"></i>
                                    </button>
                                    <div class="audio-waveform">
                                        <div class="audio-duration">üéµ Message vocal</div>
                                    </div>
                                </div>
                            `;
                        } else {
                            const fileIcon = getFileIcon(file.file_type);
                            content += `
                                <div class="message-file" onclick="downloadFile('${file.file_url}', '${file.file_name}')">
                                    <div class="file-icon">
                                        <i class="fas ${fileIcon}"></i>
                                    </div>
                                    <div class="file-info">
                                        <div class="file-name">${escapeHtml(file.file_name)}</div>
                                        <div class="file-meta">
                                            <span>${file.file_type}</span>
                                            <span>${formatFileSize(file.file_size)}</span>
                                        </div>
                                    </div>
                                    <div class="file-download">
                                        <i class="fas fa-download"></i>
                                    </div>
                                </div>
                            `;
                        }
                    });
                }
                
                if (index === messages.length - 1) {
                    let statusIcon = '';
                    let editDeleteBtns = '';
                    
                    if (isSent) {
                        if (msg.read_status) {
                            statusIcon = '<span class="message-status"><i class="fas fa-check-double" style="color: #8a9b56;"></i></span>';
                        } else if (msg.delivery_status === 'delivered') {
                            statusIcon = '<span class="message-status"><i class="fas fa-check-double"></i></span>';
                            // ‚úÖ Boutons modifier/supprimer si non lu
                            editDeleteBtns = `
                                <div class="message-actions">
                                    ${msg.texte ? `<button class="message-action-btn" onclick="editMessage('${msg.message_id}', event)" title="Modifier">
                                        <i class="fas fa-edit"></i>
                                    </button>` : ''}
                                    <button class="message-action-btn delete" onclick="deleteMessage('${msg.message_id}', event)" title="Supprimer">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            `;
                        } else if (msg.delivery_status === 'sent') {
                            statusIcon = '<span class="message-status"><i class="fas fa-check"></i></span>';
                            editDeleteBtns = `
                                <div class="message-actions">
                                    ${msg.texte ? `<button class="message-action-btn" onclick="editMessage('${msg.message_id}', event)" title="Modifier">
                                        <i class="fas fa-edit"></i>
                                    </button>` : ''}
                                    <button class="message-action-btn delete" onclick="deleteMessage('${msg.message_id}', event)" title="Supprimer">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            `;
                        }
                    }
                    content += `<div class="message-time">${formatMessageTime(msg.date_created)} ${statusIcon}</div>`;
                    content += editDeleteBtns;
                }

                content += `
                    <div class="reaction-picker">
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üòä', event)">üòä</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üòÇ', event)">üòÇ</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', '‚ù§Ô∏è', event)">‚ù§Ô∏è</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üëç', event)">üëç</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üéâ', event)">üéâ</div>
                        <div class="reaction-emoji" onclick="addReaction('${msg.message_id}', 'üî•', event)">üî•</div>
                    </div>
                `;

                div.innerHTML = content;
                groupDiv.appendChild(div);
            });

            container.appendChild(groupDiv);
        }

        function showEmptyState(title, subtitle = '') {
            document.getElementById('chat-area').innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-comments"></i>
                    <h3>${title}</h3>
                    ${subtitle ? `<p>${subtitle}</p>` : ''}
                </div>
            `;
        }

        // ==================== CHAT ====================
        async function openChat(user) {
            currentChatUser = user;
            selectedImage = null;
            selectedFile = null;
            
            // ‚úÖ Charger les permissions vocales de l'utilisateur si admin
            let targetUserVoiceEnabled = false;
            if (userProfile.role === 'admin' && user.role === 'user') {
                const { data } = await supabaseInstance
                    .from('user_voice_permissions')
                    .select('voice_enabled')
                    .eq('user_id', user.user_id)
                    .single();
                
                targetUserVoiceEnabled = data?.voice_enabled || false;
            }
            
            const initials = `${user.prenom[0]}${user.nom[0]}`.toUpperCase();
            const chatArea = document.getElementById('chat-area');

            const isAdmin = userProfile.role === 'admin';
            const showVoiceBtn = isAdmin || userVoicePermission;

            chatArea.innerHTML = `
                <div class="chat-header">
                    <div class="chat-avatar">${initials}</div>
                    <div class="chat-user-info">
                        <h3>${user.prenom} ${user.nom}</h3>
                        <p id="user-status">${user.role === 'admin' ? 'Administrateur' : 'Utilisateur'}</p>
                    </div>
                    <div class="chat-header-actions">
                        ${isAdmin && user.role === 'user' ? `
                            <button class="chat-header-btn ${targetUserVoiceEnabled ? 'voice-enabled' : ''}" 
                                    onclick="toggleUserVoicePermission('${user.user_id}', ${!targetUserVoiceEnabled})"
                                    title="${targetUserVoiceEnabled ? 'D√©sactiver' : 'Activer'} les messages vocaux">
                                <i class="fas fa-microphone${targetUserVoiceEnabled ? '' : '-slash'}"></i>
                            </button>
                        ` : ''}
                        <button class="chat-header-btn" onclick="refreshChat()" title="Actualiser">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                </div>
                <div class="chat-messages" id="chat-messages"></div>
                <div class="image-preview-container" id="image-preview-container">
                    <div class="image-preview">
                        <img id="preview-image" src="" alt="Preview">
                        <button class="remove-preview" onclick="removeImagePreview()">√ó</button>
                    </div>
                </div>
                <div class="file-preview-container" id="file-preview-container">
                    <div class="file-preview">
                        <div class="file-preview-icon" id="file-preview-icon">
                            <i class="fas fa-file"></i>
                        </div>
                        <div class="file-preview-info">
                            <div class="file-preview-name" id="file-preview-name"></div>
                            <div class="file-preview-size" id="file-preview-size"></div>
                        </div>
                        <button class="remove-file-preview" onclick="removeFilePreview()">√ó</button>
                    </div>
                </div>
                <div class="chat-input-area">
                    <input type="file" id="image-input" accept="image/*" style="display: none;" onchange="handleImageSelect(event)">
                    <input type="file" id="file-input" accept=".pdf,.zip,.mp3,.mp4,.wav,.doc,.docx,.xls,.xlsx,.avi,.mov,.rar,.7z" style="display: none;" onchange="handleFileSelect(event)">
                    <div style="position: relative;">
                        <button class="attach-btn" id="attach-btn" onclick="toggleAttachMenu()" title="Joindre un fichier">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <div class="attach-menu" id="attach-menu">
                            <div class="attach-option" onclick="document.getElementById('image-input').click(); document.getElementById('attach-menu').classList.remove('show');">
                                <i class="fas fa-image"></i>
                                <span>Photo</span>
                            </div>
                            <div class="attach-option ${!showVoiceBtn ? 'admin-only' : ''}" onclick="${showVoiceBtn ? "document.getElementById('file-input').click(); document.getElementById('attach-menu').classList.remove('show');" : "alert('Permission requise. Contactez un administrateur.');"}" title="${!showVoiceBtn ? 'Permission requise' : 'Fichiers PDF, ZIP, vid√©os, etc.'}">
                                <i class="fas fa-file"></i>
                                <span>Fichier ${!showVoiceBtn ? 'üîí' : ''}</span>
                            </div>
                            ${showVoiceBtn ? `<div class="attach-option" onclick="toggleVoiceRecording(); document.getElementById('attach-menu').classList.remove('show');" title="Enregistrement vocal">
                                <i class="fas fa-microphone"></i>
                                <span>Audio vocal</span>
                            </div>` : ''}
                        </div>
                    </div>
                    ${showVoiceBtn ? `<button class="voice-btn" id="voice-btn" onclick="toggleVoiceRecording()" title="Enregistrement vocal">
                        <i class="fas fa-microphone"></i>
                    </button>` : ''}
                    <div class="input-wrapper" onclick="openMessagePopup()">
                        <div class="message-input-placeholder">
                            Aa
                        </div>
                    </div>
                    <button class="send-btn" id="send-btn-main" onclick="sendMessage()" disabled style="display: none;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            `;

            const popupHTML = `
                <div class="message-popup-overlay" id="message-popup-overlay" onclick="closeMessagePopup()">
                    <div class="message-popup" id="message-popup" onclick="event.stopPropagation()">
                        <div class="message-popup-header">
                            <h4>Nouveau message</h4>
                            <button class="popup-close-btn" onclick="closeMessagePopup()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="message-popup-body">
                            <textarea 
                                class="message-popup-input" 
                                id="message-popup-input" 
                                placeholder="√âcrivez votre message..."
                                oninput="handlePopupInputChange()"
                                onkeydown="handlePopupKeyDown(event)"
                            ></textarea>
                        </div>
                        <div class="message-popup-footer">
                            <button class="popup-emoji-btn" onclick="insertEmojiPopup()" title="Emoji">
                                üòä
                            </button>
                            <button class="popup-send-btn" id="popup-send-btn" onclick="sendMessageFromPopup()" disabled>
                                <i class="fas fa-paper-plane"></i>
                                <span>Envoyer</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            chatArea.insertAdjacentHTML('beforeend', popupHTML);

            loadMessages(user.user_id);
            markMessagesAsRead(user.user_id);
            subscribeToMessages(user.user_id);
            subscribeToTypingStatus(user.user_id);
            subscribeToDeliveryStatus(user.user_id);
        }

        // ==================== ENVOI MESSAGES ====================
        async function sendMessage() {
            const sendBtn = document.getElementById('send-btn-main');
            const texte = ''; // Pas de texte pour les fichiers/images uniquement

            if (!selectedImage && !selectedFile) return;

            if (sendBtn) {
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            try {
                let imageUrl = null;
                let messageId = null;

                if (selectedImage) {
                    const fileName = `${Date.now()}_${selectedImage.name}`;
                    const { error: uploadError } = await supabaseInstance.storage
                        .from('messages-images')
                        .upload(fileName, selectedImage, {
                            contentType: selectedImage.type,
                            upsert: false
                        });

                    if (uploadError) throw uploadError;
                    const { data } = supabaseInstance.storage.from('messages-images').getPublicUrl(fileName);
                    imageUrl = data.publicUrl;
                }

                const { data: messageData, error: insertError } = await supabaseInstance
                    .from('messages')
                    .insert({
                        sender_id: currentUser.id,
                        receiver_id: currentChatUser.user_id,
                        texte: texte || null,
                        image_url: imageUrl,
                        delivery_status: 'sent'
                    })
                    .select()
                    .single();

                if (insertError) throw insertError;
                messageId = messageData.message_id;

                if (selectedFile && (userProfile.role === 'admin' || userVoicePermission)) {
                    const fileName = `${Date.now()}_${selectedFile.name}`;
                    
                    // ‚úÖ Choisir le bon bucket
                    const bucketName = userProfile.role === 'admin' ? 'messages-files' : 'messages-filesuser';
                    
                    const { error: fileUploadError } = await supabaseInstance.storage
                        .from(bucketName)
                        .upload(fileName, selectedFile, {
                            contentType: selectedFile.type,
                            upsert: false
                        });

                    if (fileUploadError) throw fileUploadError;
                    
                    const { data: fileUrlData } = supabaseInstance.storage
                        .from(bucketName)
                        .getPublicUrl(fileName);
                    
                    const fileType = getFileTypeFromMime(selectedFile.type, selectedFile.name);
                    
                    const { error: fileMetaError } = await supabaseInstance
                        .from('message_files')
                        .insert({
                            message_id: messageId,
                            file_url: fileUrlData.publicUrl,
                            file_name: selectedFile.name,
                            file_type: fileType,
                            file_size: selectedFile.size,
                            mime_type: selectedFile.type,
                            uploaded_by: currentUser.id
                        });

                    if (fileMetaError) throw fileMetaError;
                }
                
                removeImagePreview();
                removeFilePreview();
                
            } catch (error) {
                console.error('Erreur envoi message:', error);
                alert('Erreur lors de l\'envoi du message. Veuillez r√©essayer.');
            } finally {
                if (sendBtn) {
                    sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                    updateSendButton();
                }
            }
        }

        async function markMessagesAsRead(otherUserId) {
            try {
                await supabaseInstance
                    .from('messages')
                    .update({ 
                        read_status: true, 
                        delivery_status: 'read',
                        read_at: new Date().toISOString()
                    })
                    .eq('sender_id', otherUserId)
                    .eq('receiver_id', currentUser.id)
                    .eq('read_status', false);
                    
                await loadConversations();
            } catch (error) {
                console.error('Erreur marquage lu:', error);
            }
        }

        // ==================== ENREGISTREMENT VOCAL ====================
        async function toggleVoiceRecording() {
            // ‚úÖ V√©rifier les permissions
            if (userProfile.role !== 'admin' && !userVoicePermission) {
                alert('Vous n\'avez pas la permission d\'envoyer des messages vocaux. Contactez un administrateur.');
                return;
            }

            if (!isRecording) {
                await startVoiceRecording();
            } else {
                await stopVoiceRecording();
            }
        }

        async function startVoiceRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    await uploadVoiceMessage(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                const voiceBtn = document.getElementById('voice-btn');
                if (voiceBtn) {
                    voiceBtn.classList.add('recording');
                    voiceBtn.innerHTML = '<i class="fas fa-stop"></i>';
                }

                document.getElementById('recording-indicator').classList.add('show');
                recordingTimer = setInterval(updateRecordingTime, 1000);
                
            } catch (error) {
                console.error('Erreur acc√®s microphone:', error);
                alert('Impossible d\'acc√©der au microphone. V√©rifiez les permissions.');
            }
        }

        async function stopVoiceRecording() {
            if (!mediaRecorder || !isRecording) return;

            mediaRecorder.stop();
            isRecording = false;
            
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }

            const voiceBtn = document.getElementById('voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.remove('recording');
                voiceBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            }

            document.getElementById('recording-indicator').classList.remove('show');
        }

        function updateRecordingTime() {
            if (!recordingStartTime) return;
            
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            const timeDisplay = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recording-time').textContent = timeDisplay;
        }

        async function uploadVoiceMessage(audioBlob) {
            try {
                const { data: { session } } = await supabaseInstance.auth.getSession();
                if (!session) {
                    throw new Error('Vous devez √™tre connect√© pour envoyer un message vocal');
                }

                console.log('üé§ D√©but upload message vocal...');
                
                // ‚úÖ Choisir le bon bucket selon le r√¥le
                const bucketName = userProfile.role === 'admin' ? 'messages-files' : 'messages-filesuser';
                console.log('üì¶ Bucket utilis√©:', bucketName);
                
                const { data: messageData, error: insertError } = await supabaseInstance
                    .from('messages')
                    .insert({
                        sender_id: currentUser.id,
                        receiver_id: currentChatUser.user_id,
                        texte: null,
                        image_url: null,
                        delivery_status: 'sent'
                    })
                    .select()
                    .single();

                if (insertError) throw insertError;
                
                const messageId = messageData.message_id;
                console.log('‚úÖ Message cr√©√©:', messageId);
                
                const fileName = `voice_${Date.now()}_${currentUser.id}.wav`;
                
                const { data: uploadData, error: uploadError } = await supabaseInstance.storage
                    .from(bucketName)
                    .upload(fileName, audioBlob, {
                        contentType: 'audio/wav',
                        upsert: false
                    });

                if (uploadError) throw new Error(`Erreur Storage: ${uploadError.message}`);
                
                const { data: audioUrlData } = supabaseInstance.storage
                    .from(bucketName)
                    .getPublicUrl(fileName);

                const { error: fileMetaError } = await supabaseInstance
                    .from('message_files')
                    .insert({
                        message_id: messageId,
                        file_url: audioUrlData.publicUrl,
                        file_name: fileName,
                        file_type: 'audio',
                        file_size: audioBlob.size,
                        mime_type: 'audio/wav'
                    });

                if (fileMetaError) throw fileMetaError;
                
                console.log('‚úÖ Message vocal envoy√© avec succ√®s');
                
            } catch (error) {
                console.error('‚ùå Erreur compl√®te:', error);
                alert('Erreur lors de l\'envoi du message vocal: ' + (error.message || 'Erreur inconnue'));
            }
        }

        // ==================== SUBSCRIPTIONS ====================
        function subscribeToMessages(otherUserId) {
            if (messageSubscription) supabaseInstance.removeChannel(messageSubscription);

            messageSubscription = supabaseInstance.channel(`chat-${currentUser.id}-${otherUserId}`)
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'messages'
                }, async (payload) => {
                    if ((payload.new.sender_id === otherUserId && payload.new.receiver_id === currentUser.id) ||
                        (payload.new.sender_id === currentUser.id && payload.new.receiver_id === otherUserId)) {
                        
                        const { data: files } = await supabaseInstance
                            .from('message_files')
                            .select('*')
                            .eq('message_id', payload.new.message_id);
                        
                        payload.new.files = files || [];
                        messagesCache.push(payload.new);
                        displayMessages(messagesCache);
                        
                        if (payload.new.receiver_id === currentUser.id) {
                            markMessagesAsRead(otherUserId);
                        }
                        
                        loadConversations();
                    }
                })
                .subscribe();
        }

        async function updateTypingStatus(typing) {
            if (!currentChatUser) return;
            isTyping = typing;
            
            try {
                if (typing) {
                    await supabaseInstance
                        .from('typing_status')
                        .upsert({
                            user_id: currentUser.id,
                            chat_with_user_id: currentChatUser.user_id,
                            is_typing: true
                        });
                } else {
                    await supabaseInstance
                        .from('typing_status')
                        .delete()
                        .eq('user_id', currentUser.id)
                        .eq('chat_with_user_id', currentChatUser.user_id);
                }
            } catch (error) {
                console.error('Erreur typing status:', error);
            }
        }

        function subscribeToTypingStatus(otherUserId) {
            if (typingSubscription) supabaseInstance.removeChannel(typingSubscription);

            typingSubscription = supabaseInstance.channel(`typing-${currentUser.id}-${otherUserId}`)
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'typing_status',
                    filter: `user_id=eq.${otherUserId}`
                }, (payload) => {
                    const statusEl = document.getElementById('user-status');
                    if (!statusEl) return;
                    
                    if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                        if (payload.new.is_typing && payload.new.chat_with_user_id === currentUser.id) {
                            statusEl.innerHTML = '<span class="typing-indicator">En train d\'√©crire<span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
                        }
                    } else if (payload.eventType === 'DELETE') {
                        statusEl.textContent = currentChatUser.role === 'admin' ? 'Administrateur' : 'Utilisateur';
                    }
                })
                .subscribe();
        }

        function subscribeToDeliveryStatus(otherUserId) {
            if (deliverySubscription) supabaseInstance.removeChannel(deliverySubscription);

            deliverySubscription = supabaseInstance.channel(`delivery-${currentUser.id}-${otherUserId}`)
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'messages',
                    filter: `sender_id=eq.${currentUser.id}`
                }, (payload) => {
                    updateMessageStatus(payload.new.message_id, payload.new.delivery_status, payload.new.read_status);
                })
                .subscribe();
        }

        function updateMessageStatus(messageId, deliveryStatus, readStatus) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageEl) return;

            const statusEl = messageEl.querySelector('.message-status');
            if (!statusEl) return;

            if (readStatus) {
                statusEl.innerHTML = '<i class="fas fa-check-double" style="color: #8a9b56;"></i>';
            } else if (deliveryStatus === 'delivered') {
                statusEl.innerHTML = '<i class="fas fa-check-double"></i>';
            } else if (deliveryStatus === 'sent') {
                statusEl.innerHTML = '<i class="fas fa-check"></i>';
            }
        }

        // ==================== GESTION FICHIERS ====================
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 5000000) {
                alert('L\'image est trop volumineuse (max 5MB)');
                return;
            }

            selectedImage = file;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const previewContainer = document.getElementById('image-preview-container');
                const previewImage = document.getElementById('preview-image');
                if (previewContainer && previewImage) {
                    previewImage.src = e.target.result;
                    previewContainer.style.display = 'block';
                    updateSendButton();
                }
            };
            reader.readAsDataURL(file);
        }

        function removeImagePreview() {
            selectedImage = null;
            const previewContainer = document.getElementById('image-preview-container');
            const imageInput = document.getElementById('image-input');
            if (previewContainer) previewContainer.style.display = 'none';
            if (imageInput) imageInput.value = '';
            updateSendButton();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // ‚úÖ V√©rifier les permissions
            if (userProfile.role !== 'admin' && !userVoicePermission) {
                alert('Vous n\'avez pas la permission d\'envoyer des fichiers. Contactez un administrateur.');
                event.target.value = '';
                return;
            }

            if (file.size > 50000000) {
                alert('Le fichier est trop volumineux (max 50MB)');
                event.target.value = '';
                return;
            }

            selectedFile = file;
            
            const previewContainer = document.getElementById('file-preview-container');
            const previewName = document.getElementById('file-preview-name');
            const previewSize = document.getElementById('file-preview-size');
            const previewIcon = document.getElementById('file-preview-icon');
            
            if (previewName) previewName.textContent = file.name;
            if (previewSize) previewSize.textContent = formatFileSize(file.size);
            
            const fileType = getFileTypeFromMime(file.type, file.name);
            const iconClass = getFileIcon(fileType);
            if (previewIcon) previewIcon.innerHTML = `<i class="fas ${iconClass}"></i>`;
            
            if (previewContainer) previewContainer.style.display = 'block';
            updateSendButton();
        }

        function removeFilePreview() {
            selectedFile = null;
            const previewContainer = document.getElementById('file-preview-container');
            const fileInput = document.getElementById('file-input');
            if (previewContainer) previewContainer.style.display = 'none';
            if (fileInput) fileInput.value = '';
            updateSendButton();
        }

        // ‚úÖ Nouvelle fonction pour g√©rer l'affichage du bouton d'envoi
        function updateSendButton() {
            const sendBtn = document.getElementById('send-btn-main');
            const inputWrapper = document.querySelector('.input-wrapper');
            
            if (!sendBtn || !inputWrapper) return;
            
            const hasContent = selectedImage !== null || selectedFile !== null;
            
            if (hasContent) {
                sendBtn.style.display = 'flex';
                sendBtn.disabled = false;
                inputWrapper.style.opacity = '0.3';
                inputWrapper.style.pointerEvents = 'none';
            } else {
                sendBtn.style.display = 'none';
                inputWrapper.style.opacity = '1';
                inputWrapper.style.pointerEvents = 'auto';
            }
        }

        function playAudio(audioUrl, button) {
            const audio = new Audio(audioUrl);
            const icon = button.querySelector('i');
            
            if (!icon) return;
            
            icon.className = 'fas fa-spinner fa-spin';
            
            audio.onloadeddata = () => {
                icon.className = 'fas fa-pause';
                audio.play();
            };
            
            audio.onended = () => {
                icon.className = 'fas fa-play';
            };
            
            audio.onerror = () => {
                icon.className = 'fas fa-exclamation-triangle';
                alert('Erreur lors de la lecture du message vocal');
            };
            
            if (!audio.paused) {
                audio.pause();
                icon.className = 'fas fa-play';
            }
        }

        async function downloadFile(fileUrl, fileName) {
            try {
                const response = await fetch(fileUrl);
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Erreur t√©l√©chargement fichier:', error);
                alert('Erreur lors du t√©l√©chargement du fichier');
            }
        }

        // ==================== MODALES ====================
        function openConversationsModal() {
            displayConversations(conversationsCache);
            document.getElementById('conversations-modal').classList.add('show');
        }

        function closeConversationsModal() {
            document.getElementById('conversations-modal').classList.remove('show');
        }

        async function openContactsModal() {
            if (contactsCache.length === 0) {
                document.getElementById('contacts-list').innerHTML = '<div class="loading"><i class="fas fa-spinner fa-spin"></i><p>Chargement...</p></div>';
                document.getElementById('contacts-modal').classList.add('show');
                await loadContacts();
                displayContacts(contactsCache);
            } else {
                displayContacts(contactsCache);
                document.getElementById('contacts-modal').classList.add('show');
            }
        }

        function closeContactsModal() {
            document.getElementById('contacts-modal').classList.remove('show');
        }

        function filterList(type, query) {
            const data = type === 'conversations' ? conversationsCache : contactsCache;
            const filtered = data.filter(item => {
                const user = item.user || item;
                return `${user.prenom} ${user.nom}`.toLowerCase().includes(query.toLowerCase());
            });

            if (type === 'conversations') {
                displayConversations(filtered);
            } else {
                displayContacts(filtered);
            }
        }

        // ==================== INPUT HANDLERS ====================
        function toggleAttachMenu() {
            const menu = document.getElementById('attach-menu');
            if (menu) {
                menu.classList.toggle('show');
            }
        }

        function handleInputChange() {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            
            if (!input || !sendBtn) return;
            
            input.style.height = 'auto';
            const newHeight = Math.max(24, Math.min(input.scrollHeight, 180));
            input.style.height = newHeight + 'px';
            
            const hasContent = input.value.trim().length > 0 || selectedImage !== null || selectedFile !== null;
            sendBtn.disabled = !hasContent;
            
            if (input.value.trim().length > 0 && !isTyping) {
                updateTypingStatus(true);
            }
            
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                updateTypingStatus(false);
            }, 2000);
        }

        // ==================== POPUP DE SAISIE ====================
        function openMessagePopup() {
            const overlay = document.getElementById('message-popup-overlay');
            const input = document.getElementById('message-popup-input');
            
            if (overlay && input) {
                overlay.classList.add('show');
                setTimeout(() => {
                    input.focus();
                }, 100);
            }
        }

        function closeMessagePopup() {
            const overlay = document.getElementById('message-popup-overlay');
            const input = document.getElementById('message-popup-input');
            const sendBtn = document.getElementById('popup-send-btn');
            
            if (overlay) {
                overlay.classList.remove('show');
            }
            
            if (input) {
                input.value = '';
                input.style.height = 'auto';
            }
            
            if (sendBtn) {
                sendBtn.disabled = true;
            }
            
            updateTypingStatus(false);
        }

        function handlePopupInputChange() {
            const input = document.getElementById('message-popup-input');
            const sendBtn = document.getElementById('popup-send-btn');
            
            if (!input || !sendBtn) return;
            
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 400) + 'px';
            
            const hasContent = input.value.trim().length > 0;
            sendBtn.disabled = !hasContent;
            
            if (hasContent && !isTyping) {
                updateTypingStatus(true);
            }
            
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                updateTypingStatus(false);
            }, 2000);
        }

        function handlePopupKeyDown(event) {
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                event.preventDefault();
                sendMessageFromPopup();
            }
        }

        async function sendMessageFromPopup() {
            const input = document.getElementById('message-popup-input');
            const sendBtn = document.getElementById('popup-send-btn');
            const texte = input ? input.value.trim() : '';

            if (!texte) return;

            if (sendBtn) {
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Envoi...</span>';
            }

            updateTypingStatus(false);

            try {
                const { data: messageData, error: insertError } = await supabaseInstance
                    .from('messages')
                    .insert({
                        sender_id: currentUser.id,
                        receiver_id: currentChatUser.user_id,
                        texte: texte,
                        image_url: null,
                        delivery_status: 'sent'
                    })
                    .select()
                    .single();

                if (insertError) throw insertError;

                closeMessagePopup();
                
            } catch (error) {
                console.error('Erreur envoi message:', error);
                alert('Erreur lors de l\'envoi du message. Veuillez r√©essayer.');
                
                if (sendBtn) {
                    sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i><span>Envoyer</span>';
                    sendBtn.disabled = false;
                }
            }
        }

        function insertEmojiPopup() {
            const emojis = ['üòä', 'üòÇ', '‚ù§Ô∏è', 'üëç', 'üéâ', 'üî•', 'üòç', 'ü§î', 'üëè', 'üôè'];
            const emoji = emojis[Math.floor(Math.random() * emojis.length)];
            const input = document.getElementById('message-popup-input');
            if (input) {
                input.value += emoji;
                input.focus();
                handlePopupInputChange();
            }
        }

        function openImageFullscreen(imageUrl) {
            window.open(imageUrl, '_blank');
        }

        function refreshChat() {
            if (currentChatUser) {
                loadMessages(currentChatUser.user_id);
                loadConversations();
            }
        }

        // ==================== MODIFIER/SUPPRIMER MESSAGES ====================
        async function editMessage(messageId, event) {
            event.stopPropagation();
            
            // Trouver le message dans le cache
            const message = messagesCache.find(m => m.message_id === messageId);
            if (!message || !message.texte) {
                alert('Impossible de modifier ce message');
                return;
            }

            // ‚úÖ Cr√©er un popup moderne pour la modification
            const popup = document.createElement('div');
            popup.className = 'message-popup-overlay show';
            popup.innerHTML = `
                <div class="message-popup" onclick="event.stopPropagation()">
                    <div class="message-popup-header">
                        <h4>Modifier le message</h4>
                        <button class="popup-close-btn" onclick="this.closest('.message-popup-overlay').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="message-popup-body">
                        <textarea 
                            class="message-popup-input" 
                            id="edit-message-input"
                            placeholder="Modifiez votre message..."
                        >${escapeHtmlForEdit(message.texte)}</textarea>
                    </div>
                    <div class="message-popup-footer">
                        <button class="popup-send-btn secondary" onclick="this.closest('.message-popup-overlay').remove()">
                            Annuler
                        </button>
                        <button class="popup-send-btn" id="save-edit-btn" onclick="saveEditedMessage('${messageId}')">
                            <i class="fas fa-check"></i>
                            <span>Enregistrer</span>
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // Focus sur le textarea
            setTimeout(() => {
                const textarea = document.getElementById('edit-message-input');
                if (textarea) {
                    textarea.focus();
                    textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                }
            }, 100);
        }

        async function saveEditedMessage(messageId) {
            const textarea = document.getElementById('edit-message-input');
            const newText = textarea ? textarea.value.trim() : '';
            
            if (!newText) {
                alert('Le message ne peut pas √™tre vide');
                return;
            }

            const saveBtn = document.getElementById('save-edit-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Enregistrement...</span>';
            }

            try {
                // ‚úÖ V√©rifier d'abord que le message n'est pas lu
                const { data: msgCheck, error: checkError } = await supabaseInstance
                    .from('messages')
                    .select('read_status, sender_id')
                    .eq('message_id', messageId)
                    .single();

                if (checkError) throw checkError;

                if (msgCheck.read_status) {
                    alert('‚ùå Ce message a d√©j√† √©t√© lu, impossible de le modifier');
                    document.querySelector('.message-popup-overlay').remove();
                    return;
                }

                if (msgCheck.sender_id !== currentUser.id) {
                    alert('‚ùå Vous n\'√™tes pas l\'auteur de ce message');
                    document.querySelector('.message-popup-overlay').remove();
                    return;
                }

                // ‚úÖ Modifier le message (SANS updated_at)
                const { error: updateError } = await supabaseInstance
                    .from('messages')
                    .update({ 
                        texte: newText
                    })
                    .eq('message_id', messageId);

                if (updateError) throw updateError;

                console.log('‚úÖ Message modifi√©');
                
                // Mettre √† jour le cache local
                const message = messagesCache.find(m => m.message_id === messageId);
                if (message) {
                    message.texte = newText;
                    displayMessages(messagesCache);
                }

                // Fermer le popup
                document.querySelector('.message-popup-overlay').remove();

            } catch (error) {
                console.error('‚ùå Erreur modification message:', error);
                alert('Erreur lors de la modification du message: ' + (error.message || 'Erreur inconnue'));
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = '<i class="fas fa-check"></i><span>Enregistrer</span>';
                }
            }
        }

        function escapeHtmlForEdit(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function deleteMessage(messageId, event) {
            event.stopPropagation();
            
            if (!confirm('‚ùå Supprimer d√©finitivement ce message ?')) return;

            try {
                // R√©cup√©rer les fichiers associ√©s pour les supprimer du Storage
                const message = messagesCache.find(m => m.message_id === messageId);
                if (message && message.files && message.files.length > 0) {
                    // Supprimer les fichiers du Storage
                    for (const file of message.files) {
                        const fileName = file.file_url.split('/').pop();
                        const bucketName = userProfile.role === 'admin' ? 'messages-files' : 'messages-filesuser';
                        
                        await supabaseInstance.storage
                            .from(bucketName)
                            .remove([fileName]);
                    }
                }

                // Supprimer le message via la fonction RPC
                const { error } = await supabaseInstance
                    .rpc('delete_message_with_files', {
                        msg_id: messageId
                    });

                if (error) {
                    if (error.message.includes('d√©j√† √©t√© lu')) {
                        alert('‚ùå Ce message a d√©j√† √©t√© lu, impossible de le supprimer');
                    } else {
                        throw error;
                    }
                    return;
                }

                console.log('‚úÖ Message supprim√©');
                
                // Retirer du cache local
                messagesCache = messagesCache.filter(m => m.message_id !== messageId);
                displayMessages(messagesCache);
                loadConversations();

            } catch (error) {
                console.error('‚ùå Erreur suppression message:', error);
                alert('Erreur lors de la suppression du message');
            }
        }

        // ==================== UTILITAIRES ====================
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/\n/g, '<br>');
        }

        function formatFileSize(bytes) {
            if (!bytes) return 'Taille inconnue';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function getFileIcon(fileType) {
            const icons = {
                'video': 'fa-file-video',
                'audio': 'fa-file-audio',
                'pdf': 'fa-file-pdf',
                'zip': 'fa-file-archive',
                'document': 'fa-file-word',
                'other': 'fa-file'
            };
            return icons[fileType] || 'fa-file';
        }

        function getFileTypeFromMime(mimeType, fileName) {
            if (mimeType.startsWith('video/')) return 'video';
            if (mimeType.startsWith('audio/')) return 'audio';
            if (mimeType === 'application/pdf') return 'pdf';
            if (mimeType === 'application/zip' || mimeType === 'application/x-zip-compressed') return 'zip';
            if (mimeType.includes('word') || fileName.endsWith('.doc') || fileName.endsWith('.docx')) return 'document';
            if (mimeType.includes('excel') || fileName.endsWith('.xls') || fileName.endsWith('.xlsx')) return 'document';
            return 'other';
        }

        function formatTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;

            if (diff < 60000) return '√Ä l\'instant';
            if (diff < 3600000) return `${Math.floor(diff / 60000)} min`;
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            }
            
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'Hier';
            }
            
            return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
        }

        function formatMessageTime(dateString) {
            const date = new Date(dateString);
            return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDateSeparator(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            
            if (date.toDateString() === now.toDateString()) {
                return 'Aujourd\'hui';
            }
            
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'Hier';
            }
            
            return date.toLocaleDateString('fr-FR', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
        }

        // ==================== EVENT LISTENERS ====================
        document.getElementById('conversations-modal').addEventListener('click', function(e) {
            if (e.target === this) closeConversationsModal();
        });

        document.getElementById('contacts-modal').addEventListener('click', function(e) {
            if (e.target === this) closeContactsModal();
        });

        window.addEventListener('beforeunload', () => {
            updateTypingStatus(false);
            if (mediaRecorder && isRecording) {
                stopVoiceRecording();
            }
            if (messageSubscription) supabaseInstance.removeChannel(messageSubscription);
            if (typingSubscription) supabaseInstance.removeChannel(typingSubscription);
            if (deliverySubscription) supabaseInstance.removeChannel(deliverySubscription);
            if (reactionSubscription) supabaseInstance.removeChannel(reactionSubscription);
        });

        setInterval(() => {
            if (!document.hidden && currentUser) {
                loadConversations();
            }
        }, 30000);
    </script>
</body>
    </html>
